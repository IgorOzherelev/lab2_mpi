1) Ускорение и эффективность параллельных алгоритмов

	S = T_1 / T_n - ускорение, в качестве T_1 понимается лучшее время последовательного алгоритма

	E = S / p - эффективность, определяет масштабируемость
	(рациональность использования конкретного количества процессов)


2) Закон Амдала
	S = 1 / (a + (1 - a) / p)
	a - доля последовательных расчетов
	p - число процессов

3) Свойство канала передачи данных. Латентность
	Латентностью (задержкой) называется время, затрачиваемое программным обеспечением и устройствами сети на подготовку к передаче информации по данному каналу. Полная латентность складывается из программной и аппаратной составляющих.

4) Виды обменов «точка-точка»: синхронные, асинхронные. Буферизация данных.
	Пропускная способность однонаправленных пересылок ("точка-точка", uni-directional bandwidth), равная максимальной скорости, с которой процесс на одном узле может передавать данные другому процессу на другом узле.

5) Синхронизация выполнения.
	семафоры, мьютексы, мониторы
	в openmp есть, например, такие штуки:
	void omp_init_lock(omp_lock_t* lock); - 1 захват на один поток
	void omp_init_nest_lock(omp_lock_t* lock); - многократный захват одним потоком

6) Условия Бернстайна
	Пусть в программе имеются два оператора S1 и S2, непосредственно динамически следующих друг за другом. Пусть W(S) – набор выходных переменных оператора S, а R(S) – набор его входных переменных. Тогда возможность их одновременного выполнения различными исполнителями в параллельной системе можно определить с помощью условий Бернстайна

	Если для операторов S1 и S2, непосредственно динамически следующих друг за
	другом, выполнено:
	а) пересечение W(S1) и W(S2) пусто;
	б) пересечение W(S1) и R(S2) пусто;
	в) пересечение R(S1) и W(S2) пусто;
	то они могут быть исполнены параллельно.


7) Расстояние зависимости. Его влияние на возможность распараллеливания простого цикла
	D = λ − κ

	D < 0 - существует антизависимость. Цикл может быть распараллелен так, что каждая итерация будет выполняться отдельным исполнителем, если перед началом выполнения итераций продублировать необходимые входные данные на исполнителях.

	Если расстояние зависимости D > 0, то между операторами тела цикла существует потоковая зависимость. При D > 1 цикл может быть распараллелен не более чем на D исполнителях.
	
	Если расстояние зависимости D = 0, то тип зависимости между операторами тела цикла в общем случае не определен. Цикл может быть распараллелен так, что каждая итерация будет выполняться отдельным исполнителем.


8) Расстояние зависимости для вложенных циклов
	D = Λ − K (из вектора итераций, соответствующего итерации стока зависимости, вычитаем вектор итерации, соответствующий итерации источника зависимости).

9) Вектор направлений. Его влияние на возможность распараллеливания вложенных
циклов.
	di = „ = “, Di = 0;
  	di = „ > “, Di < 0;
 	di = „ <“, Di > 0.

 	d = („=“, . . . , „=“), то цикл может быть распараллелен без ограничений
 	можно переставлять местами циклы.

 	d, в состав которого входят только элементы «>» и «=»
 	«>» в векторе направлений, возможно при дублировании необходимых входных данных.

 	d, в состав которого входят только элементы „<“ и „=“.
 	„<“ в векторе направлений, проблематично.

10) Условия возможности перестановки вложенных циклов с сохраненнием результата
вычислений

	Для произвольного цикла возможно распараллеливание по любому индексу,
	соответствующему компоненту „=“ в векторе направлений. Уровень вложенности,
	соответствующий этому компоненту, можно поменять местами с любым соседним
	уровнем вложенности с сохранением результата вычислений

11) Проанилизировать возможность распараллеливания следующих циклов:
	1) for (int i=0; i<N; ++i) { a[i] = d[i] + 5*i; c[i] = a[2*i] * 2;}
		зависимость по данным: 2*λ = k
		D < 0 => Цикл может быть распараллелен так, что каждая итерация будет выполняться отдельным исполнителем, если перед началом выполнения итераций продублировать необходимые входные данные на исполнителях.

	2) for (int i=0; i<N; ++i) { c[i] = sin(a[2*i]); a[i] = d[i]*2; }
		D > 0 => нельзя есть зависимость
		Размер D определить нельзя

	3) for (int i=0; i<N; ++i) { a[i] = a[i-1]*2;}
		во-первых это ошибка на первой же итерации))
		λ = k - 1
		d = 1 > 0 => нельзя
	4) for (int i=0; i<N; ++i) { a[i] = a[i+4]/2;}
		d = -4, Цикл может быть распараллелен так, что каждая итерация будет выполняться отдельным исполнителем, если перед началом выполнения итераций продублировать необходимые входные данные на исполнителях.
	
	5) for (int i=0; i<N; ++i) { a[i] = a[i+4]*tan(a[i-1]);}
	во-первых это ошибка на первой же итерации))
	расстояние зависимости точно обределить нельзя(оно разных знаков для двух случаев) => нельзя распараллелить


